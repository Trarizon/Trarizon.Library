using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.CodeDom.Compiler;
using System.Linq;
using System.Threading;
using Trarizon.Library.Roslyn.CSharp;
using Trarizon.Library.Roslyn.Emitting;
using Trarizon.Library.Roslyn.Extensions;

namespace Trarizon.Library.Generators;
[Generator(LanguageNames.CSharp)]
internal partial class OptionalOutGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var filter = context.SyntaxProvider.ForAttributeWithMetadataName(
            Type_Attribute_FullName,
            (node, token) => node is ParameterSyntax,
            Emitter.Parse);

        context.RegisterSourceOutputAndPrintDebug(filter);
    }

    private sealed class Emitter(
        MethodDeclarationSyntax methodDeclaration,
        IMethodSymbol methodSymbol,
        ParameterSyntax parameterSyntax,
        IParameterSymbol parameterSymbol) : ISourceEmitterWithIndentedWriter
    {
        public string GeneratedFileName => $"{methodSymbol.ToValidFileNameString()}.{parameterSymbol.Name}.g.cs";

        public static DiagnosticResult<Emitter> Parse(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
        {
            if (context.TargetNode is not ParameterSyntax prmSyntax)
                return default;
            if (context.TargetSymbol is not IParameterSymbol prmSymbol)
                return default;
            if (prmSymbol.RefKind is not RefKind.Out)
                return default;

            if (prmSyntax.Parent?.Parent is not MethodDeclarationSyntax methodDecl)
                return default;
            if (prmSymbol.ContainingSymbol is not IMethodSymbol methodSymbol)
                return default;

            return new Emitter(methodDecl, methodSymbol, prmSyntax, prmSymbol);
        }

        public void Emit(IndentedTextWriter writer)
        {
            writer.WriteLine(Literals.Code_AutoGenerated_TopTrivia);
            writer.WriteLine();

            var typeSyntax = methodDeclaration.FirstAncestorOrSelf<TypeDeclarationSyntax>();

            using (writer.EmitContainingTypesAndNamespaces(methodSymbol, methodDeclaration)) {
                var parameterList = methodDeclaration.ParameterList;
                var parameters = SyntaxFactory.SeparatedList(parameterList.Parameters.Except([parameterSyntax]));

                var method = methodDeclaration
                    .WithParameterList(SyntaxFactory.ParameterList(parameters))
                    .WithBody(null)
                    .WithExpressionBody(
                        SyntaxFactory.ArrowExpressionClause(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(methodDeclaration.Identifier),
                                SyntaxFactory.ArgumentList(
                                    SyntaxFactory.SeparatedList(
                                        parameterList.Parameters
                                        .Zip(methodSymbol.Parameters, (syntax, symbol) => (syntax, symbol))
                                        .Select(p =>
                                        {
                                            var (syntax, symbol) = p;
                                            var synk = symbol.RefKind switch
                                            {
                                                RefKind.Ref => SyntaxKind.RefKeyword,
                                                RefKind.Out => SyntaxKind.OutKeyword,
                                                RefKind.In => SyntaxKind.InKeyword,
                                                RefKind.RefReadOnlyParameter => SyntaxKind.InKeyword,
                                                _ => SyntaxKind.None,
                                            };
                                            return SyntaxFactory.Argument(
                                                null,
                                                SyntaxFactory.Token(synk),
                                                SymbolEqualityComparer.Default.Equals(symbol, parameterSymbol)
                                                    ? SyntaxFactory.IdentifierName("_")
                                                    : SyntaxFactory.IdentifierName(syntax.Identifier));
                                        }))))))
                    .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));

                writer.WriteMultipleLines(method.NormalizeWhitespace().ToFullString());
            }
        }
    }
}
