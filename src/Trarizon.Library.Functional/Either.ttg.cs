// <auto-generated />

#nullable enable

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace Trarizon.Library.Functional;
public static partial class Either
{
    [DoesNotReturn]
    internal static void ThrowInvalidTag() => throw new InvalidOperationException("Invalid tag value");
}

public readonly struct Either<T1, T2, T3>
{
    private readonly byte _tag;
    internal readonly T1? _item1;
    internal readonly T2? _item2;
    internal readonly T3? _item3;

    #region Accessors

    [MemberNotNullWhen(true, nameof(_item1))]
    [MemberNotNullWhen(false, nameof(_item2), nameof(_item3))]
    public bool IsItem1 => _tag == 0;

    public T1 Item1 => _item1!;

    public T1 GetItem1OrDefault() => _item1!;

    [MemberNotNullWhen(true, nameof(_item1))]
    public bool TryGetItem1([MaybeNullWhen(false)] out T1 value)
    {
        value = _item1;
        return IsItem1;
    }

    [MemberNotNullWhen(true, nameof(_item2))]
    [MemberNotNullWhen(false, nameof(_item1), nameof(_item3))]
    public bool IsItem2 => _tag == 1;

    public T2 Item2 => _item2!;

    public T2 GetItem2OrDefault() => _item2!;

    [MemberNotNullWhen(true, nameof(_item2))]
    public bool TryGetItem2([MaybeNullWhen(false)] out T2 value)
    {
        value = _item2;
        return IsItem2;
    }

    [MemberNotNullWhen(true, nameof(_item3))]
    [MemberNotNullWhen(false, nameof(_item1), nameof(_item2))]
    public bool IsItem3 => _tag == 2;

    public T3 Item3 => _item3!;

    public T3 GetItem3OrDefault() => _item3!;

    [MemberNotNullWhen(true, nameof(_item3))]
    public bool TryGetItem3([MaybeNullWhen(false)] out T3 value)
    {
        value = _item3;
        return IsItem3;
    }

    #endregion

    #region Creators

    private Either(byte tag, T1? item1, T2? item2, T3? item3)
        => (_tag, _item1, _item2, _item3) = (tag, item1, item2, item3);

    public Either(T1 item1) : this(0, item1, default, default) { }

    public static implicit operator Either<T1,  T2,  T3>(T1 item1) => new(item1);

    public Either(T2 item2) : this(1, default, item2, default) { }

    public static implicit operator Either<T1,  T2,  T3>(T2 item2) => new(item2);

    public Either(T3 item3) : this(2, default, default, item3) { }

    public static implicit operator Either<T1,  T2,  T3>(T3 item3) => new(item3);

    #endregion

    #region Converters

    public TResult Match<TResult>(Func<T1, TResult> item1Selector, Func<T2, TResult> item2Selector, Func<T3, TResult> item3Selector)
    {
        switch (_tag) {
            case 0: 
                Debug.Assert(IsItem1);
                return item1Selector.Invoke(_item1!);
            case 1: 
                Debug.Assert(IsItem2);
                return item2Selector.Invoke(_item2!);
            case 2: 
                Debug.Assert(IsItem3);
                return item3Selector.Invoke(_item3!);
            default: 
                Either.ThrowInvalidTag();
                return default!;
        }
    }

    public void Match(Action<T1>? item1Selector, Action<T2>? item2Selector, Action<T3>? item3Selector)
    {
        switch (_tag) {
            case 0:
                Debug.Assert(IsItem1);
                item1Selector?.Invoke(_item1!);
                return;
            case 1:
                Debug.Assert(IsItem2);
                item2Selector?.Invoke(_item2!);
                return;
            case 2:
                Debug.Assert(IsItem3);
                item3Selector?.Invoke(_item3!);
                return;
            default: 
                Either.ThrowInvalidTag();
                return;
        }
    }

    public Either<TNew, T2, T3> SelectItem1<TNew>(Func<T1, TNew> selector)
    {
        switch (_tag) {
            case 0:
                Debug.Assert(IsItem1);
                return new(selector(_item1!));
            case 1:
                Debug.Assert(IsItem2);
                return new(_item2!);
            case 2:
                Debug.Assert(IsItem3);
                return new(_item3!);
            default: 
                Either.ThrowInvalidTag();
                return default!;
        }
    }

    public Either<T1, TNew, T3> SelectItem2<TNew>(Func<T2, TNew> selector)
    {
        switch (_tag) {
            case 0:
                Debug.Assert(IsItem1);
                return new(_item1!);
            case 1:
                Debug.Assert(IsItem2);
                return new(selector(_item2!));
            case 2:
                Debug.Assert(IsItem3);
                return new(_item3!);
            default: 
                Either.ThrowInvalidTag();
                return default!;
        }
    }

    public Either<T1, T2, TNew> SelectItem3<TNew>(Func<T3, TNew> selector)
    {
        switch (_tag) {
            case 0:
                Debug.Assert(IsItem1);
                return new(_item1!);
            case 1:
                Debug.Assert(IsItem2);
                return new(_item2!);
            case 2:
                Debug.Assert(IsItem3);
                return new(selector(_item3!));
            default: 
                Either.ThrowInvalidTag();
                return default!;
        }
    }

    public Either<TNew, T2, T3> BindItem1<TNew>(Func<T1, Either<TNew, T2, T3>> selector)
    {
        switch (_tag) {
            case 0:
                Debug.Assert(IsItem1);
                return selector(_item1!);
            case 1:
                Debug.Assert(IsItem2);
                return new(_item2!);
            case 2:
                Debug.Assert(IsItem3);
                return new(_item3!);
            default: 
                Either.ThrowInvalidTag();
                return default!;
        } 
    }

    public Either<T1, TNew, T3> BindItem2<TNew>(Func<T2, Either<T1, TNew, T3>> selector)
    {
        switch (_tag) {
            case 0:
                Debug.Assert(IsItem1);
                return new(_item1!);
            case 1:
                Debug.Assert(IsItem2);
                return selector(_item2!);
            case 2:
                Debug.Assert(IsItem3);
                return new(_item3!);
            default: 
                Either.ThrowInvalidTag();
                return default!;
        } 
    }

    public Either<T1, T2, TNew> BindItem3<TNew>(Func<T3, Either<T1, T2, TNew>> selector)
    {
        switch (_tag) {
            case 0:
                Debug.Assert(IsItem1);
                return new(_item1!);
            case 1:
                Debug.Assert(IsItem2);
                return new(_item2!);
            case 2:
                Debug.Assert(IsItem3);
                return selector(_item3!);
            default: 
                Either.ThrowInvalidTag();
                return default!;
        } 
    }

    #endregion

    public override string ToString()
    {
        switch (_tag) {
            case 0:
                Debug.Assert(IsItem1);
                return _item1!.ToString() ?? string.Empty;
            case 1:
                Debug.Assert(IsItem2);
                return _item2!.ToString() ?? string.Empty;
            case 2:
                Debug.Assert(IsItem3);
                return _item3!.ToString() ?? string.Empty;
            default: 
                Either.ThrowInvalidTag();
                return default!;
        }
    }
}

