using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.CodeDom.Compiler;
using System.IO;
using System.Linq;
using System.Threading;
using Trarizon.Library.GeneratorToolkit;
using Trarizon.Library.GeneratorToolkit.ContextModelExtensions;
using Trarizon.Library.GeneratorToolkit.CSharp;
using Trarizon.Library.GeneratorToolkit.Wrappers;
using static Trarizon.Library.SourceGeneration.Generators.OptionalOutLiterals;

namespace Trarizon.Library.SourceGeneration.Generators;
[Generator(LanguageNames.CSharp)]
internal class OptionalOutGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var filter = context.SyntaxProvider.ForAttributeWithMetadataName(
            L_Attribute_TypeName,
            (node, token) =>
            {
                return node is ParameterSyntax;
            },
            Emitter.Parse);

        context.RegisterSourceOutputAndPrintDebug(filter);
    }

    private sealed class Emitter(
        MethodDeclarationSyntax methodDeclaration,
        IMethodSymbol methodSymbol,
        ParameterSyntax outParameterSyntax,
        IParameterSymbol outParameterSymbol) : ISourceEmitter
    {
        public static ParseResult<ISourceEmitter> Parse(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
        {
            if (context.TargetNode is not ParameterSyntax parameterSyntax)
                return default;
            if (context.TargetSymbol is not IParameterSymbol parameterSymbol)
                return default;
            if (parameterSymbol.RefKind is not RefKind.Out)
                return default;

            if (parameterSyntax.Parent?.Parent is not MethodDeclarationSyntax methodSyntax)
                return default;
            if (parameterSymbol.ContainingSymbol is not IMethodSymbol methodSymbol)
                return default;

            return new Emitter(methodSyntax, methodSymbol, parameterSyntax, parameterSymbol);
        }

        public string Emit()
        {
            var sw = new StringWriter();
            var writer = new IndentedTextWriter(sw);

            writer.WriteLine(Literals.AutoGenerated_TopTrivia_Code);
            writer.WriteLine();

            var typeSyntax = methodDeclaration.FirstAncestorOrSelf<TypeDeclarationSyntax>();

            using (writer.EmitContainingTypesAndNamespaces(methodSymbol, methodDeclaration)) {
                var parameterList = methodDeclaration.ParameterList;
                var parameters = SyntaxFactory.SeparatedList(
                    parameterList.Parameters.Except([outParameterSyntax]));

                var method = methodDeclaration
                    .WithParameterList(SyntaxFactory.ParameterList(parameters))
                    .WithBody(null)
                    .WithExpressionBody(
                        SyntaxFactory.ArrowExpressionClause(
                            SyntaxFactory.InvocationExpression(
                                SyntaxFactory.IdentifierName(methodDeclaration.Identifier),
                                SyntaxFactory.ArgumentList(
                                    SyntaxFactory.SeparatedList(
                                        parameterList.Parameters
                                            .Zip(methodSymbol.Parameters, (syntax, symbol) => (syntax, symbol))
                                            .Select(p =>
                                            {
                                                var (syntax, symbol) = p;
                                                var refk = symbol.RefKind switch
                                                {
                                                    RefKind.Ref => SyntaxKind.RefKeyword,
                                                    RefKind.Out => SyntaxKind.OutKeyword,
                                                    RefKind.In => SyntaxKind.InKeyword,
                                                    RefKind.RefReadOnlyParameter => SyntaxKind.InKeyword,
                                                    _ => SyntaxKind.None,
                                                };
                                                return SyntaxFactory.Argument(null,
                                                    SyntaxFactory.Token(refk),
                                                    SymbolEqualityComparer.Default.Equals(symbol, outParameterSymbol)
                                                        ? SyntaxFactory.IdentifierName("_")
                                                        : SyntaxFactory.IdentifierName(syntax.Identifier));
                                            }))))))
                    .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));

                writer.WriteMultipleLines(method.NormalizeWhitespace().ToFullString());

            }

            return sw.ToString();
        }

        public string GenerateFileName() => $"{methodSymbol.ToValidFileNameString()}_{outParameterSymbol.Name}.g.cs";
    }
}
