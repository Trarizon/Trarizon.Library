using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using System.Linq;
using System.Text;
using Trarizon.Library.GeneratorToolkit.Extensions;

namespace Trarizon.Library.SourceGenerator.Interceptors;
[Generator(LanguageNames.CSharp)]
internal class EnumHasAnyFlagInterceptor : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodsInvocations = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, token) =>
            {
                return node is InvocationExpressionSyntax
                {
                    Expression: MemberAccessExpressionSyntax
                    {
                        Name.Identifier.ValueText: "HasAnyFlag"
                    }
                };
            },
            static (context, token) =>
            {
                var semanticModel = context.SemanticModel;
                var symbol = semanticModel.GetSymbolInfo(context.Node).Symbol as IMethodSymbol;

                if (!symbol!.ContainingType.MatchDisplayString("Trarizon.Library.TraEnum"))
                    return null;

                var operation = context.SemanticModel.GetOperation(context.Node, token);
                if (operation is IInvocationOperation invocation) {
                    return invocation;
                }
                else {
                    return null;
                }
            })
            .Where(op => op != null)
            .Collect()
            .Select(static (invocations, token) =>
            {
                return invocations
                    .GroupBy<IInvocationOperation, ITypeSymbol>(invocation => invocation.TargetMethod.TypeArguments[0], SymbolEqualityComparer.Default)
                    .Select(group =>
                    {
                        var type = group.Key;
                        var typeString = type.ToFullQualifiedDisplayString();
                        var attrs = group.Select(op =>
                        {
                            var (filePath, line, column) = GetLocation(op);
                            return $@"        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(@""{filePath}"", {line}, {column})]";
                        });
                        var defination = $$"""
                                    public static bool HasAnyFlag(this {{typeString}} value, {{typeString}} flag) => (value & flag) != 0;
                            """;
                        return (attrs, defination);
                    });
            });

        context.RegisterSourceOutput(methodsInvocations, (context, source) =>
        {
            var sb = new StringBuilder();

            if (!source.Any())
                return;

            foreach (var (attrs, defination) in source) {
                foreach (var attr in attrs) {
                    sb.AppendLine(attr);
                }
                sb.AppendLine(defination);
            }

            var code = $$"""
            // <auto-generated />

            #pragma warning disable CS9113

            namespace System.Runtime.CompilerServices
            {
                [global::System.AttributeUsageAttribute(AttributeTargets.Method, AllowMultiple = true)]
                [global::System.Diagnostics.Conditional("CODE_ANALYSIS")]
                file sealed class InterceptsLocationAttribute(string filePath, int line, int character) : global::System.Attribute;
            }

            namespace Trarizon.Library.Generated
            {
                {{Literals.GeneratedCodeAttributeList_Code}}
                internal static class __EnumHasAnyFlagInterceptors
                {
            {{sb}}    }
            }
            """;

            context.AddSource("EnumHasAnyFlagInterceptor.g.cs", code);
        });
    }

    private static (string FilePath, int Line, int Column) GetLocation(IInvocationOperation invocation)
    {
        var invocationExpressionSyntax = (InvocationExpressionSyntax)invocation.Syntax;
        var memberAccessExpressionSyntax = (MemberAccessExpressionSyntax)invocationExpressionSyntax.Expression;
        var invocationNameSpan = memberAccessExpressionSyntax.Name.Span;
        var syntaxTree = invocationExpressionSyntax.SyntaxTree;

        var lineSpan = syntaxTree.GetLineSpan(invocationNameSpan);
        var filePath = GetIntercepterFilePath(syntaxTree, invocation.SemanticModel?.Compilation.Options.SourceReferenceResolver);
        return (filePath, lineSpan.StartLinePosition.Line + 1, lineSpan.StartLinePosition.Character + 1);
    }

    private static string GetIntercepterFilePath(SyntaxTree syntaxTree, SourceReferenceResolver? resolver)
    {
        return resolver?.NormalizePath(syntaxTree.FilePath, null) ?? syntaxTree.FilePath;
    }
}
