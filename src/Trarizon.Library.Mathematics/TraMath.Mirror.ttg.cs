/// <auto-generated />

namespace Trarizon.Library.Mathematics;
public static partial class TraMath
{
#if NETSTANDARD

    #region GCD / LCM

    #region For int

    public static int GreatestCommonDivisor(int left, int right)
    {
        while (right != 0) {
            var tmp = left;
            left = right;
            right = tmp % right;
        }
        return left;
    }

    public static int LeastCommonMultiple(int left, int right)
        => left * right / GreatestCommonDivisor(left, right);

    #endregion

    #region For long

    public static long GreatestCommonDivisor(long left, long right)
    {
        while (right != 0) {
            var tmp = left;
            left = right;
            right = tmp % right;
        }
        return left;
    }

    public static long LeastCommonMultiple(long left, long right)
        => left * right / GreatestCommonDivisor(left, right);

    #endregion

    #endregion

    #region IncAndWrap/Mod

    #region For short

    public static bool IncAndTryWrap(ref short number,  short delta,  short max)
    {
        number += delta;
        if (number > max) {
            number -= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndWrap(ref short number, short delta, short max)
    {
        number += delta;
        if (number > max) {
            number -= max;
        }
    }

    public static bool IncAndTryMod(ref short number, short delta, short max)
    {
        number += delta;
        if (number > max) {
            number %= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndMod(ref short number, short delta, short max)
    {
        number += delta;
        if (number > max) {
            number %= max;
        }
    }

    #endregion

    #region For ushort

    public static bool IncAndTryWrap(ref ushort number,  ushort delta,  ushort max)
    {
        number += delta;
        if (number > max) {
            number -= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndWrap(ref ushort number, ushort delta, ushort max)
    {
        number += delta;
        if (number > max) {
            number -= max;
        }
    }

    public static bool IncAndTryMod(ref ushort number, ushort delta, ushort max)
    {
        number += delta;
        if (number > max) {
            number %= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndMod(ref ushort number, ushort delta, ushort max)
    {
        number += delta;
        if (number > max) {
            number %= max;
        }
    }

    #endregion

    #region For int

    public static bool IncAndTryWrap(ref int number,  int delta,  int max)
    {
        number += delta;
        if (number > max) {
            number -= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndWrap(ref int number, int delta, int max)
    {
        number += delta;
        if (number > max) {
            number -= max;
        }
    }

    public static bool IncAndTryMod(ref int number, int delta, int max)
    {
        number += delta;
        if (number > max) {
            number %= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndMod(ref int number, int delta, int max)
    {
        number += delta;
        if (number > max) {
            number %= max;
        }
    }

    #endregion

    #region For uint

    public static bool IncAndTryWrap(ref uint number,  uint delta,  uint max)
    {
        number += delta;
        if (number > max) {
            number -= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndWrap(ref uint number, uint delta, uint max)
    {
        number += delta;
        if (number > max) {
            number -= max;
        }
    }

    public static bool IncAndTryMod(ref uint number, uint delta, uint max)
    {
        number += delta;
        if (number > max) {
            number %= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndMod(ref uint number, uint delta, uint max)
    {
        number += delta;
        if (number > max) {
            number %= max;
        }
    }

    #endregion

    #region For long

    public static bool IncAndTryWrap(ref long number,  long delta,  long max)
    {
        number += delta;
        if (number > max) {
            number -= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndWrap(ref long number, long delta, long max)
    {
        number += delta;
        if (number > max) {
            number -= max;
        }
    }

    public static bool IncAndTryMod(ref long number, long delta, long max)
    {
        number += delta;
        if (number > max) {
            number %= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndMod(ref long number, long delta, long max)
    {
        number += delta;
        if (number > max) {
            number %= max;
        }
    }

    #endregion

    #region For ulong

    public static bool IncAndTryWrap(ref ulong number,  ulong delta,  ulong max)
    {
        number += delta;
        if (number > max) {
            number -= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndWrap(ref ulong number, ulong delta, ulong max)
    {
        number += delta;
        if (number > max) {
            number -= max;
        }
    }

    public static bool IncAndTryMod(ref ulong number, ulong delta, ulong max)
    {
        number += delta;
        if (number > max) {
            number %= max;
            return true;
        }
        else {
            return false;
        }
    }

    public static void IncAndMod(ref ulong number, ulong delta, ulong max)
    {
        number += delta;
        if (number > max) {
            number %= max;
        }
    }

    #endregion

    #endregion
    
    #region Map

    #region For float

    /// <summary>
    /// Linear normalize value into [0,1]
    /// </summary>
    public static float Normalize(float min, float max, float value)
    {
        if (min == max)
            return 0;

        return Clamp((value - min) / (max - min), 0f, 1f);
    }

    /// <summary>
    /// Linear normalize value without clamp the result into [0, 1]
    /// <br/>
    /// eg in range [5,10], 15 result in 5, 0 result in -1
    /// </summary>
    public static float NormalizeUnclamped(float min, float max, float value)
    {
        if (min == max)
            return 0;
        return (value - min) / (max - min);
    }

    /// <summary>
    /// Linear map a value from [<paramref name="fromMin"/>, <paramref name="fromMax"/>] 
    /// to [<paramref name="toMin"/>, <paramref name="toMax"/>]. The method does not clamp value
    /// </summary>
    public static float MapTo(float value, float fromMin, float fromMax, float toMin, float toMax)
    {
        var lerp = (value - fromMin) / (fromMax - fromMin);
        return (toMax - toMin) * lerp + toMin;
    }

    public static float MapToClamped(float value, float fromMin, float fromMax, float toMin, float toMax)
    {
        var lerp = (value - fromMin) / (fromMax - fromMin);
        return Clamp((toMax - toMin) * lerp + toMin, toMin, toMax);
    }

    #endregion

    #region For double

    /// <summary>
    /// Linear normalize value into [0,1]
    /// </summary>
    public static double Normalize(double min, double max, double value)
    {
        if (min == max)
            return 0;

        return Clamp((value - min) / (max - min), 0f, 1f);
    }

    /// <summary>
    /// Linear normalize value without clamp the result into [0, 1]
    /// <br/>
    /// eg in range [5,10], 15 result in 5, 0 result in -1
    /// </summary>
    public static double NormalizeUnclamped(double min, double max, double value)
    {
        if (min == max)
            return 0;
        return (value - min) / (max - min);
    }

    /// <summary>
    /// Linear map a value from [<paramref name="fromMin"/>, <paramref name="fromMax"/>] 
    /// to [<paramref name="toMin"/>, <paramref name="toMax"/>]. The method does not clamp value
    /// </summary>
    public static double MapTo(double value, double fromMin, double fromMax, double toMin, double toMax)
    {
        var lerp = (value - fromMin) / (fromMax - fromMin);
        return (toMax - toMin) * lerp + toMin;
    }

    public static double MapToClamped(double value, double fromMin, double fromMax, double toMin, double toMax)
    {
        var lerp = (value - fromMin) / (fromMax - fromMin);
        return Clamp((toMax - toMin) * lerp + toMin, toMin, toMax);
    }

    #endregion

    #endregion

    #region MinMax

    #region For short

    /// <summary>
    /// Returns min, max in one time
    /// </summary>
    /// <returns>
    /// If <paramref name="left"/> equals <paramref name="right"/>, the return value is (<paramref name="left"/>, <paramref name="right"/>),
    /// else Min is the less one
    /// </returns>
    public static (short Min, short Max) MinMax(short left, short right)
    {
        if (left <= right)
            return (left, right);
        else
            return (right, left);
    }

    #endregion

    #region For ushort

    /// <summary>
    /// Returns min, max in one time
    /// </summary>
    /// <returns>
    /// If <paramref name="left"/> equals <paramref name="right"/>, the return value is (<paramref name="left"/>, <paramref name="right"/>),
    /// else Min is the less one
    /// </returns>
    public static (ushort Min, ushort Max) MinMax(ushort left, ushort right)
    {
        if (left <= right)
            return (left, right);
        else
            return (right, left);
    }

    #endregion

    #region For int

    /// <summary>
    /// Returns min, max in one time
    /// </summary>
    /// <returns>
    /// If <paramref name="left"/> equals <paramref name="right"/>, the return value is (<paramref name="left"/>, <paramref name="right"/>),
    /// else Min is the less one
    /// </returns>
    public static (int Min, int Max) MinMax(int left, int right)
    {
        if (left <= right)
            return (left, right);
        else
            return (right, left);
    }

    #endregion

    #region For uint

    /// <summary>
    /// Returns min, max in one time
    /// </summary>
    /// <returns>
    /// If <paramref name="left"/> equals <paramref name="right"/>, the return value is (<paramref name="left"/>, <paramref name="right"/>),
    /// else Min is the less one
    /// </returns>
    public static (uint Min, uint Max) MinMax(uint left, uint right)
    {
        if (left <= right)
            return (left, right);
        else
            return (right, left);
    }

    #endregion

    #region For long

    /// <summary>
    /// Returns min, max in one time
    /// </summary>
    /// <returns>
    /// If <paramref name="left"/> equals <paramref name="right"/>, the return value is (<paramref name="left"/>, <paramref name="right"/>),
    /// else Min is the less one
    /// </returns>
    public static (long Min, long Max) MinMax(long left, long right)
    {
        if (left <= right)
            return (left, right);
        else
            return (right, left);
    }

    #endregion

    #region For ulong

    /// <summary>
    /// Returns min, max in one time
    /// </summary>
    /// <returns>
    /// If <paramref name="left"/> equals <paramref name="right"/>, the return value is (<paramref name="left"/>, <paramref name="right"/>),
    /// else Min is the less one
    /// </returns>
    public static (ulong Min, ulong Max) MinMax(ulong left, ulong right)
    {
        if (left <= right)
            return (left, right);
        else
            return (right, left);
    }

    #endregion

    #region For float

    /// <summary>
    /// Returns min, max in one time
    /// </summary>
    /// <returns>
    /// If <paramref name="left"/> equals <paramref name="right"/>, the return value is (<paramref name="left"/>, <paramref name="right"/>),
    /// else Min is the less one
    /// </returns>
    public static (float Min, float Max) MinMax(float left, float right)
    {
        if (left <= right)
            return (left, right);
        else
            return (right, left);
    }

    #endregion

    #region For double

    /// <summary>
    /// Returns min, max in one time
    /// </summary>
    /// <returns>
    /// If <paramref name="left"/> equals <paramref name="right"/>, the return value is (<paramref name="left"/>, <paramref name="right"/>),
    /// else Min is the less one
    /// </returns>
    public static (double Min, double Max) MinMax(double left, double right)
    {
        if (left <= right)
            return (left, right);
        else
            return (right, left);
    }

    #endregion

    #endregion

#endif
}
